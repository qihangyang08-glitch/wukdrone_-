

# WuK无人机项目技术文档 - 阶段一：SITL 物理仿真实现

**日期：** 2025年11月28日
**版本：** v1.0
**负责人：** 电控组
**目标：** 在 ArduPilot 仿真环境中构建支持“电机向内倾转”的变构无人机物理模型。

---

## 1. ArduPilot SITL 仿真架构解析

在进行代码修改前，必须理解 ArduPilot 的仿真后端是如何工作的。

### 1.1 前后端分离架构
ArduPilot 的 SITL 实际上分为两个完全独立的部分：
1.  **飞控固件 (Firmware):** 运行真正的飞行控制代码（姿态解算、PID、导航）。它认为自己控制的是真实的硬件，输出 PWM 信号。
2.  **物理后端 (Physics Backend):** 即 `libraries/SITL` 文件夹下的代码。它模拟真实的物理世界（重力、空气动力、电机推力）。

**数据流向：**
> 飞控输出 PWM -> **SIM_Frame (物理模型)** -> 计算推力与力矩 -> 更新飞机位置/速度 (牛顿定律) -> 反馈传感器数据给飞控

### 1.2 核心文件与类
*   **文件路径：** `libraries/SITL/SIM_Frame.cpp` (核心物理定义)
*   **关键类：** `class Motor`
    *   SITL 通过 `Motor` 类定义每个螺旋桨的位置、角度和**动态自由度**。
    *   我们利用了 `Motor` 的重载构造函数，实现了将舵机通道 (Servo Channel) 映射到电机的物理倾角 (Roll/Pitch Tilt)。

---

## 2. 代码修改实施方案

为了规避 Python 启动脚本配置的复杂性，我们采用了 **“鸠占鹊巢 (Hijack Strategy)”** 方案，即直接替换默认的 `quad` 机型定义。

### 2.1 修改位置
*   **文件：** `~/ardupilot/libraries/SITL/SIM_Frame.cpp`

### 2.2 定义 WuK 电机布局
我们在 `SIM_Frame.cpp` 中定义了一个名为 `wuk_motors` 的静态数组。
**核心逻辑：**
*   使用 **X 型布局** (45/-135/-45/135度)。
*   绑定 **Servo 9 (代码中索引为8)** 作为变构控制通道。
*   设定 **Roll轴倾转范围**：
    *   右侧电机 (Mot 1, 4)：`0` 到 `-90` 度 (向内/向左倒)。
    *   左侧电机 (Mot 2, 3)：`0` 到 `90` 度 (向内/向右倒)。

**代码片段：**
```cpp
static Motor wuk_motors[] =
{
    // 参数说明: (电机ID, 物理方位角, 旋向, 显示顺序, Roll舵机通道, Roll最小角, Roll最大角)
    
    // 右前电机 (M1): 通道9控制, 0 -> -90度
    Motor(AP_MOTORS_MOT_1,   45, AP_MOTORS_MATRIX_YAW_FACTOR_CCW, 1, 8, 0, -90),
    
    // 左后电机 (M2): 通道9控制, 0 -> 90度
    Motor(AP_MOTORS_MOT_2, -135, AP_MOTORS_MATRIX_YAW_FACTOR_CCW, 3, 8, 0, 90),
    
    // 左前电机 (M3): 通道9控制, 0 -> 90度
    Motor(AP_MOTORS_MOT_3,  -45, AP_MOTORS_MATRIX_YAW_FACTOR_CW,  4, 8, 0, 90),
    
    // 右后电机 (M4): 通道9控制, 0 -> -90度
    Motor(AP_MOTORS_MOT_4,  135, AP_MOTORS_MATRIX_YAW_FACTOR_CW,  2, 8, 0, -90),
};
```

### 2.3 注册机型 (Hijack)
在 `supported_frames` 数组中，将默认的 `quad` 定义替换为我们的 `wuk_motors`。

**修改前：**
```cpp
Frame("quad", 4, quad_plus_motors),
```
**修改后：**
```cpp
Frame("quad", 4, wuk_motors), // 名字仍叫quad，但物理实质已变为WuK
```

---

## 3. 编译与部署

每次修改 C++ 代码后，必须重新编译。

### 3.1 编译指令 (Waf)
在 WSL 终端中执行：
```bash
# 如果是大改动，建议先清理
./waf distclean
./waf configure --board sitl

# 标准编译
./waf copter
```
*成功标志：终端显示 `'build' finished successfully`*

### 3.2 启动仿真
由于我们替换了默认机型，无需指定 `-f` 参数：
```bash
sim_vehicle.py -v ArduCopter --console --map
```

---

## 4. 测试与验证流程

使用 MAVProxy 控制台进行指令测试。

### 4.1 基础飞行测试
验证无人机在未变形状态下（垂直模式）是否具备正常的四旋翼飞行特性。

```bash
mode guided       # 切换到引导模式
arm throttle      # 解锁电机
takeoff 20        # 起飞至 20米
```
*   **预期：** 飞机稳定悬停，高度保持 20m。
*   **机动测试：**
    *   `rc 2 1400` (前飞)：飞机应向北移动。
    *   `rc 4 1400` (左转)：飞机应逆时针旋转 (注意回中 `rc 4 1500`)。

### 4.2 变构物理验证 (关键)
验证我们植入的物理模型是否生效。

**操作：**
在悬停状态下，强制输出 PWM 信号给变构通道 (Servo 9)。
```bash
servo set 9 1900
```

**预期现象：**
1.  **姿态：** 飞机保持水平（因为左右倾转力矩相互抵消）。
2.  **高度：** **急剧下降/坠落**。
    *   *原理：* 电机推力矢量从垂直向下 ($F_z = 100\%$) 变为水平向内 ($F_z \approx 0\%$)，升力消失。
3.  **恢复：** 输入 `servo set 9 1100` 后，若高度足够，飞机应能恢复升力并重新悬停。

### 4.3 故障排查 (Debug)
如果 `servo set` 无反应：
1.  **检查通道映射：** `param set SERVO9_FUNCTION 59` (RC PassThrough)。
2.  **代码探针：** 在 `SIM_Frame.cpp` 的 `update_forces` 函数首行插入 `printf`，打印 `input.servos[8]` 的值，确认物理引擎是否接收到了 PWM 信号。

---

## 5. 下一步计划 (Phase 2)

既然物理世界的“假飞机”已经造好了，下一阶段我们将深入飞控固件内部（C++），开发能控制这架飞机的“真大脑”。

1.  **ArduPilot 源码剖析：** 学习 `AP_Motors` 库的混控逻辑。
2.  **动态混控算法开发：**
    *   创建新的飞行模式 `ModeMorph`。
    *   编写 C++ 代码，根据变形角度 $\theta$ 实时调整 Roll/Pitch/Yaw 的混控权重。
    *   实现 `Mixer = f(Angle)` 的动态映射，保证变构过程中的姿态可控性。
