

# 📘 ArduPilot SITL 仿真架构修改与扩展指南

**版本：** 1.0 (通用版)
**适用对象：** 高级飞控开发者 / 机器人动力学研究员
**核心目标：** 深入理解 SITL 物理后端架构，掌握自定义机型、动力学模型及物理特性的修改方法。

---

## 1. 架构总览：大脑与身体的分离

在进行代码修改前，必须建立一个清晰的认知：**SITL (Software In The Loop)** 并非飞控本身，而是飞控的“替身世界”。

*   **ArduCopter (Firmware/Frontend):** 是“大脑”。它只负责计算 PID、导航和姿态解算，最终输出 PWM 信号。它**不知道**自己是在飞真机还是在电脑里跑。
*   **SITL (Physics Backend):** 是“身体”和“环境”。它接收 PWM，计算牛顿力学（力与力矩），然后欺骗大脑说：“这是现在的陀螺仪和 GPS 数据”。

**我们的修改战场，主要集中在“身体”部分 (`libraries/SITL`)。**

### 核心数据流向
```text
[飞控固件] 
    | 输出 (PWM 信号)
    v
[SIM_Frame] (机架层：总管)
    | 分发 PWM
    v
[SIM_Motor] (动力层：执行器)
    | 计算单体推力 & 扭矩 & 矢量方向
    v
[Physics Engine] (物理核心：积分器)
    | 合成合力 -> 计算加速度 -> 积分出速度/位置
    v
[Sensor Models] (传感器模型)
    | 生成 IMU, GPS, Baro 数据
    v
[飞控固件] (闭环反馈)
```

---

## 2. 核心模块一：SIM_Frame (骨架与布局)

`SIM_Frame` 是物理仿真的入口，它定义了飞行器的**几何构型**和**整体物理属性**。如果你要创造一个长得不一样的飞机，或者一个会变形的飞机，这里是起点。

### 2.1 职责与功能
1.  **定义电机阵列 (Motor Array):** 决定了飞机有几个电机，每个电机装在哪里（位置），朝向哪里（推力矢量），以及它是正转还是反转（偏航系数）。
2.  **物理循环入口 (`update_forces`):** 这是每一帧物理计算的主循环。它是介入“全局物理逻辑”的最佳位置。
3.  **机型注册 (`supported_frames`):** 决定了启动指令（如 `-f quad`）对应哪一套物理参数。

### 2.2 修改方法论：由静态到动态
*   **初级修改（静态构型）：**
    通过定义静态的 `Motor` 结构体数组，你可以创造 X 型、+ 型、六旋翼甚至非对称机型。这相当于“搭积木”。
*   **高级修改（动态/变构机型）：**
    标准的 SITL 认为机架是刚体。要实现**变构**，你必须打破“静态”的假设。
    *   **劫持策略 (Hijack Strategy):** 不必费力去写一个新的类，可以直接修改现有的机型定义（如 `quad`），将其指向你自定义的电机数组。
    *   **动态干预:** 在 `update_forces` 循环中，读取辅助通道（如 Servo 9）的 PWM 值，根据数学模型实时修改电机的物理属性（如推力方向 `thrust_vector`）。

---

## 3. 核心模块二：SIM_Motor (肌肉与动力)

如果说 `SIM_Frame` 决定了电机在哪，那么 `SIM_Motor` 就决定了电机**如何产生力**。当你需要更深度的动力学模拟（如推力矢量控制、特殊动力响应）时，必须下沉到这里。

### 3.1 职责与功能
1.  **推力计算 (`calculate_forces`):** 将输入的 PWM 信号（无量纲）转化为牛顿（Force）和牛顿米（Torque）。
2.  **矢量管理:** 维护一个 `thrust_vector`（推力向量）。在普通四旋翼中，它是固定的 $(0, 0, -1)$。但在变构机型中，它是可变的。
3.  **舵机模拟:** 如果电机是可倾转的（Tilt-Rotor），这里负责模拟舵机的响应速度和角度限制。

### 3.2 修改方法论：开放权限与接口
*   **权限突破:** 默认情况下，`thrust_vector` 等核心属性是 `private` 的，以保护物理稳定性。为了实现非常规控制，我们往往需要将其改为 `public`，或提供 `setter` 接口（如 `set_external_tilt`）。
*   **优先级逻辑:** 在 `calculate_forces` 中，你需要设计一套逻辑：是优先使用内部的舵机模拟，还是优先使用来自 Frame 层的外部强制指令？
*   **平滑与限幅:** 物理世界没有瞬移。在修改电机角度时，必须引入**斜率限制 (Slew Rate)**，模拟真实的机械运动速度，否则仿真数据会出现非物理的阶跃。

---

## 4. 实战开发路径：从何下手？

根据实践经验，开发一个新型仿真模型通常遵循以下路径：

### 第一步：建立“假身” (Structure Definition)
*   **位置:** `libraries/SITL/SIM_Frame.cpp`
*   **操作:** 定义一个新的 `static Motor my_motors[]` 数组。
*   **目的:** 确定电机的物理布局（位置、初始角度）。利用“鸠占鹊巢”法，将默认启动参数指向这个新数组，快速验证环境。

### 第二步：打通“神经” (Signal Flow)
*   **位置:** `libraries/SITL/SIM_Frame.cpp` -> `update_forces`
*   **操作:** 插入调试代码（`printf`），打印特定通道的 PWM 输入。
*   **目的:** 确保飞控的控制信号能无损传输到物理引擎内部。如果这里是 0，说明飞控参数配置有误，物理改得再好也没用。

### 第三步：注入“灵魂” (Physics Logic)
*   **位置:** `libraries/SITL/SIM_Frame.cpp` (全局逻辑) 或 `SIM_Motor.cpp` (单体逻辑)
*   **操作:** 编写 C++ 代码，将 PWM 信号映射为物理量的变化（如旋转矩阵计算）。
*   **关键点:**
    *   **封装:** 尽量避免在 Frame 层直接操作 Motor 的私有变量，应在 Motor 层提供标准 API。
    *   **保护:** 增加 NaN 检查和归一化处理，防止数学计算错误导致仿真崩溃（Reset）。

### 第四步：建立“黑匣子” (Data & Visualization)
*   **操作:** 不要只看飞控的日志，要在 SITL 源码中直接将物理状态（真实推力矢量、电机角度）写入自定义日志或 CSV。
*   **目的:** 飞控记录的是“它认为的状态”，SITL 记录的是“真实的物理状态”。对比两者差异，是调试控制算法的关键。

---

## 5. 总结：SITL 编程思维

修改 SITL 代码，本质上是在扮演**“上帝”**。

1.  **你定义物理定律：** 你可以让电机推力随风速变化，也可以让机臂随信号折叠。
2.  **数据是一切：** 3D 画面（Gazebo）只是表象，SITL 内部计算的向量和力才是真理。
3.  **先跑通，再优雅：** 先用 `public` 变量和硬编码验证物理假设（Crash Test），确认物理逻辑成立后，再用 C++ 的封装特性将其重构为标准接口。

掌握了 `SIM_Frame` 和 `SIM_Motor` 的交互逻辑，你就掌握了在虚拟世界中创造任何飞行器的能力。