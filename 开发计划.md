

### 第一阶段：SITL 入门与环境搭建（Level 0 -> Level 10）

**目标：** 让你的电脑能跑通 ArduPilot 仿真，并学会编译代码。

1.  **环境准备（不要在 Windows 直接搞，必坑）：**
    *   **推荐：** 使用 **WSL2 (Windows Subsystem for Linux)** 安装 Ubuntu 20.04 或 22.04。这是目前开发 ArduPilot 最顺滑的方式。
    *   **工具链：** 按照官网文档安装 `git`, `gcc-arm-none-eabi`, `python3` 等依赖。
    *   **编译系统：** 学会使用 `waf`。
        *   `./waf configure --board sitl` (配置为仿真板)
        *   `./waf copter` (编译多旋翼固件)
        *   `sim_vehicle.py -v ArduCopter --console --map` (启动仿真，带地图和控制台)

2.  **关键任务：**
    *   成功运行一次仿真，在地图上看到飞机，并用键盘或虚拟摇杆解锁（Arm）、起飞（Takeoff）。
    *   随便修改一行代码（比如在 `Copter.cpp` 的 setup 里加一句 `hal.console->printf("Hello WuK Drone\n");`），重新编译并运行，看到这行字打印出来。**这一步跑通，由于你就能控制整个世界了。**

### 第二阶段：自定义仿真模型（Level 10 -> Level 40）

**目标：** 让仿真里的飞机长得像你的“WuK Drone”，具备这一版特殊的物理特性。

**核心痛点：** 原生 SITL 里只有标准的四旋翼。你需要教仿真器：我的电机是可以转的。

1.  **修改物理后端 (Physics Backend)：**
    *   **文件路径：** `libraries/SITL/SIM_Frame.cpp` 和 `SIM_Frame.h`
    *   **操作：** 找到 `setup_frame` 函数。你可以基于 `X` 型四旋翼修改。
    *   **挑战：** 这里定义了电机的位置和推力方向。你需要引入一个变量（模拟舵机角度），并在每一帧更新 `motors` 的推力矢量。
    *   *注：初期可以先不把物理模型做成动态的，先定义两个模型：一个纯四旋翼，一个纯地面车，验证两套逻辑。等熟练了再把它们写成一个动态变化的物理模型。*

### 第三阶段：开发地面/水面模式逻辑（Level 40 -> Level 70）

**目标：** 抛弃 Arduino 的逻辑，在 ArduPilot 内部实现“风力驱动车”的控制。

这部分是你熟悉代码的绝佳练手场，因为在地面测试不会摔坏东西。

1.  **新建飞行模式：**
    *   **参考对象：** 复制 `ModeManual` 或 `ModeAcro` 的代码，重命名为 `ModeGround`。
    *   **文件：** `ArduCopter/mode.h`, `ArduCopter/mode_ground.cpp` (新建)。

2.  **重写输出逻辑 (Mixer Override)：**
    *   **难点：** 此时飞控仍以为自己在飞，会尝试平衡姿态。你需要在 `ModeGround` 中**旁路掉姿态控制**。
    *   **伪代码逻辑：**
        ```cpp
        // 在 ModeGround::run() 中
        float throttle = channel_throttle->get_control_in(); // 油门杆
        float steering = channel_roll->get_control_in();     // 横滚杆当方向盘

        // 简单的差速逻辑
        float motor_left = throttle + steering;
        float motor_right = throttle - steering;

        // 强制写入电机输出（跳过姿态环）
        motors->set_output_scaled(MOT_1, motor_left);
        motors->set_output_scaled(MOT_2, motor_right);
        ...
        ```
    *   **验证：** 在 SITL 里切到 `ModeGround`，推油门，看模拟器里的 PWM 输出条是否随你的逻辑变化。

### 第四阶段：空中变构与着陆算法（Level 70 -> Level 100）

**目标：** 实现那个惊险的“空中变形 + 自动切断动力”。

1.  **实现动态混控 (Dynamic Mixer)：**
    *   回到 `libraries/AP_Motors/AP_MotorsMatrix.cpp`。
    *   你需要把上一阶段“旁路姿态环”的做法升级。这次我们要保留姿态环，但是改变姿态环控制电机的方式。
    *   建立 `add_motor_raw` 的动态更新机制，输入参数是 `current_servo_angle`。

2.  **编写状态机 (State Machine)：**
    *   新建 `ModeMorphLand`。
    *   **逻辑链：**
        *   `if (switch_triggered)` -> 发送 Mavlink 指令给 SITL 物理后端（模拟舵机开始转）。
        *   同时，在混控里更新矩阵。
        *   `if (angle > 60_deg || height < 0.2m)` -> `motors->armed(false)` (强制加锁)。

3.  **SITL 验证：**
    *   在仿真中把飞机飞到 10 米高。
    *   触发变形。
    *   观察虚拟示波器：电机 1-4 的输出曲线是否正如你设计的“前馈补偿”那样猛增？
    *   观察高度曲线：飞机是否在变构后平稳（或至少可控地）触地？

---

### 这里的关键技术难点（帮你预警）

在你的学习过程中，最大的拦路虎不是 C++ 语法，而是 **ArduPilot 的调度机制**。

1.  **频率问题：** 你的主循环 `fast_loop` 是 400Hz。确保你的变构逻辑计算量不要太大，否则会导致飞控 CPU 过载（Watchdog Reset）。
2.  **归一化陷阱：** ArduPilot 内部大量使用 -1.0 到 1.0 的浮点数，或者是 1000-2000 的 PWM 值。在写代码时一定要搞清楚当前变量的单位，否则电机可能会突然满转。
3.  **安全开关：** 在实机调试前，**务必**在代码里写死一个“杀手开关”（Kill Switch），比如“如果在任何模式下通道 8 大于 1800，立即停转电机”，并且这个逻辑的优先级要高于你的变构算法。

### 给你布置的“第一周作业”

别想太远，先做最基础的：
1.  搭建好 WSL2 + ArduPilot 编译环境。
2.  编译出固件，运行 `sim_vehicle.py`。
3.  **作业题：** 找到控制“飞行模式”切换的代码段，尝试修改代码，使得当你切换到 `Stabilize` 模式时，终端自动打印一行：“WuK Stabilize Mode Active”。

完成这一步，你就正式通过了 ArduPilot 开发者的入门考试。随时可以把你的报错信息发给我，我来帮你 Debug。加油！
