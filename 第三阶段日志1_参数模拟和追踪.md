
---

### 📂 状态复原日志 (Checkpoint: Controlled Crash)

**核心原理回顾：**
我们没有使用 Gazebo（因为网络通信不稳定），而是直接修改了 **ArduPilot 内置的仿真物理引擎 (SITL)**。我们通过“暴力手段”强行接管了电机推力方向的计算逻辑。

#### 1. 权限破解 (`libraries/SITL/SIM_Frame.h`)
为了能修改电机的推力方向，我们把私有变量变成了公有。
*   **操作：** 找到 `class Motor` 定义。
*   **修改：** 将 `Vector3f thrust_vector;` 从 `private:` 区域剪切到了 `public:` 区域。

#### 2. 逻辑劫持 (`libraries/SITL/SIM_Frame.cpp`)
这是实现“坠机”的核心。我们在物理引擎每帧更新受力时，强行插入了一段代码。
*   **位置：** `void Frame::update_forces(...)` 函数的**最开头**。
*   **插入代码（核心逻辑）：**
    ```cpp
    // === 1. 暴力强制更新电机角度 ===
    for (uint8_t i=0; i<num_motors; i++) {
        // 如果电机配置了 Roll 舵机 (这里我们之前通过鸠占鹊巢把 roll_servo 设为了 8)
        if (motors[i].roll_servo >= 0) {
            // 获取通道 9 (Index 8) 的 PWM 值
            uint16_t pwm = input.servos[motors[i].roll_servo];
            
            // 计算 0.0 ~ 1.0 的比例
            float t = (pwm - 1000.0f) / 1000.0f;
            if (t < 0) t = 0; if (t > 1) t = 1;

            // 计算当前角度 (线性插值)
            float current_roll = motors[i].roll_min + (motors[i].roll_max - motors[i].roll_min) * t;
            
            // 【关键】构建旋转矩阵，暴力修改 thrust_vector
            Matrix3f m;
            m.from_euler(radians(current_roll), 0, 0); 
            motors[i].thrust_vector = m * Vector3f(0, 0, -1);
        }
    }
    ```

#### 3. 听诊器探针 (`libraries/SITL/SIM_Frame.cpp`)
为了验证是否生效，我们在上述代码下方加了打印。
*   **插入代码：**
    ```cpp
    // === 2. 调试打印 ===
    static int debug_counter = 0;
    if (debug_counter++ % 100 == 0) {
        // 打印 Z 分量。-1.0 表示垂直向上升力，0.0 表示无升力
        hal.console->printf(">>> WUK: PWM9=%d | Mot0_Z=%f <<<\n", 
                             input.servos[8], 
                             motors[0].thrust_vector.z);
    }
    ```

#### 4. 机型注册 (`libraries/SITL/SIM_Frame.cpp`)
为了确保 SITL 加载我们的配置，我们修改了 `supported_frames`。
*   **位置：** 文件底部的 `static Frame supported_frames[]`。
*   **修改：** 把 `Frame("quad", ...)` 改成了指向我们自定义的 `wuk_motors` 数组。

---

### 🚀 如何验证“这就是变形引起的”？

你现在的顾虑是：“飞机掉下来了，是因为推力方向变了？还是因为我不小心把油门切断了？”

利用你的 **Copilot Pro** 和现有的**探针**，我们可以设计一个严谨的实验。

#### 第一步：让 Copilot 审查代码逻辑 (Review)
打开 VS Code，打开 `SIM_Frame.cpp`，选中我们插入的那段 `update_forces` 代码。
**在 Copilot Chat 中输入以下 Prompt：**

> "I have injected this code into the SITL physics engine. Can you analyze the math logic? Specifically:
> 1. Does the `Matrix3f` rotation correctly rotate the `thrust_vector` based on `current_roll`?
> 2. If `current_roll` is 90 degrees, what will be the value of `thrust_vector.z`?
> 3. Does this code affect the magnitude (length) of the thrust vector, or only the direction?"

*Copilot 会告诉你：它只改变方向，不改变大小。这是验证“没有切断油门”的理论依据。*

#### 第二步：添加“推力大小”监控 (Verify Output Intensity)
我们不仅要看 Z 分量（方向），还要看**总推力大小**。如果总推力没变，只是 Z 分量没了，那就是纯粹的变形导致的。

**请修改探针代码：**

```cpp
    if (debug_counter++ % 100 == 0) {
        // 计算推力矢量的长度 (Magnitude)
        float thrust_len = motors[0].thrust_vector.length();
        
        hal.console->printf(">>> WUK: PWM9=%d | Vector_Z=%f | Thrust_Mag=%f <<<\n", 
                             input.servos[8], 
                             motors[0].thrust_vector.z,
                             thrust_len);
    }
```

#### 第三步：执行控制变量实验

1.  **编译并启动 SITL (纯 2D 模式):**
    ```bash
    ./waf copter
    sim_vehicle.py -v ArduCopter --console
    ```
2.  **起飞悬停:** `takeoff 20`
3.  **观察数据 A (正常态):**
    *   `PWM9` = 1000 (或 1100)
    *   `Vector_Z` ≈ -1.0
    *   `Thrust_Mag` ≈ 1.0
4.  **执行变形:** `servo set 9 1900`
5.  **观察数据 B (变形态):**
    *   **如果** `Vector_Z` 变成 **0.0** (或接近 0)
    *   **且** `Thrust_Mag` 依然保持 **1.0** (说明电机还在全速转，只是方向歪了)
    *   **且** 飞机高度狂掉

**结论：** 这就 100% 证明了坠机是由**矢量偏转**引起的，而不是动力丧失。

