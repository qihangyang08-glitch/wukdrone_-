

### 第一路：生成并烧录 Arduino 固件

这部分最简单，建议直接在 Windows 环境下使用 **Arduino IDE** 操作，避免 WSL 的 USB 穿透问题。

#### 1. 准备代码
*   把你之前确认好的 Arduino 代码（包含 `[Header, Cmd, Data, Checksum]` 解析逻辑和舵机驱动逻辑的代码），保存为 `WuK_Slave.ino`。

#### 2. 编译与上传
1.  **打开 Arduino IDE**（在 Windows 上）。
2.  **打开文件：** `File` -> `Open` -> 选择 `WuK_Slave.ino`。
3.  **安装库（如果还没装）：**
    *   如果你用了 `Servo.h`，这是自带的，不用装。
    *   如果你用了特殊的串口库，需要在 `Sketch` -> `Include Library` -> `Manage Libraries` 里安装。
4.  **选择开发板：**
    *   `Tools` -> `Board` -> `Arduino Mega or Mega 2560`。
    *   `Tools` -> `Processor` -> `ATmega2560 (Mega 2560)`。
5.  **选择端口：** 插上 USB，在 `Tools` -> `Port` 里选择对应的 COM 口。
6.  **验证 (Verify)：** 点击左上角的“对号”图标。确保底部显示 "Done compiling"，没有红色报错。
7.  **上传 (Upload)：** 点击“右箭头”图标。等待底部显示 "Done uploading"。

#### 3. 验证 Arduino 是否活著
*   保持 USB 连接，打开 IDE 右上角的 **Serial Monitor (串口监视器)**。
*   波特率选 **115200** (或者你代码里写的 `Serial.begin` 的数值)。
*   你应该能看到代码里写的初始化打印，比如 `System Ready`。
*   *(此时飞控还没接过来，所以不会有动作，但只要有打印，说明程序跑起来了)*

---

### 第二路：生成并烧录 ArduPilot 飞控固件

这部分稍微复杂一点，分为 **“WSL 编译”** 和 **“Windows 烧录”** 两步。

#### 1. 确定板型 ID (Board ID)
你之前提过飞控是 **“微空 H743 V2”**。在 ArduPilot 的编译系统中，它对应的板型名称通常是 **`MatekH743`**。

为了保险，我们先在 WSL 终端里查一下：
```bash
cd ~/ardupilot
./waf list_boards | grep Matek
```
*   你应该能看到 `MatekH743`。

#### 2. 编译固件 (在 WSL 终端操作)
我们要从 SITL 模式切换回物理硬件编译模式。

1.  **清理旧环境（必须做）：**
    ```bash
    ./waf distclean
    ```
2.  **配置为 H743 硬件：**
    ```bash
    ./waf configure --board MatekH743
    ```
    *(注：如果你的飞控不是这个型号，请替换成正确的名字，比如 `Durandal` 或 `Pixhawk1`)*
3.  **编译多旋翼固件：**
    ```bash
    ./waf copter
    ```
4.  **等待编译完成：** 这次编译会比 SITL 慢一些，因为要编译底层驱动。等待出现 `'build' finished successfully`。

#### 3. 导出固件文件 (从 Linux 拿出来)
编译好的文件藏在 WSL 的深处。我们需要把它复制到 Windows 桌面，方便烧录。

编译生成的文件路径通常是：
`~/ardupilot/build/MatekH743/bin/arducopter.apj`

**导出命令（在 WSL 终端执行）：**
假设你的 Windows 用户名是 `User`，我们把它复制到 Windows 桌面：
```bash
# 注意替换 'User' 为你的 Windows 用户名
cp ~/ardupilot/build/MatekH743/bin/arducopter.apj /mnt/c/Users/User/Desktop/wuk_firmware_v1.apj
```
*   *现在，去你的 Windows 桌面上看看，有没有一个叫 `wuk_firmware_v1.apj` 的文件？*

#### 4. 烧录固件 (在 Windows 上使用 Mission Planner)
1.  用 USB 线把飞控连上电脑。
2.  打开 **Mission Planner**。
3.  **不要点击连接 (Connect)**，保持断开状态。
4.  进入 **SETUP (设置)** 菜单 -> **Install Firmware (安装固件)**。
5.  点击右下角的 **“Load custom firmware” (加载自定义固件)** 链接（通常是绿色的小字）。
6.  选择你桌面上那个 `wuk_firmware_v1.apj` 文件。
7.  Mission Planner 会提示“是否烧录”，点 Yes。
8.  等待进度条走完，飞控重启并发出音乐声。

---

### 第三步：硬件接线与参数配置 (合体)

两个脑子都刷好系统了，现在要把它们连起来。

#### 1. 物理接线 (请断电操作)
按我们之前商定的方案：
*   **飞控 UART (如 TELEM2) TX** ---> **Arduino RX1 (Pin 19)**
*   **飞控 UART (如 TELEM2) RX** ---> **Arduino TX1 (Pin 18)** (如果需要回传)
*   **飞控 GND** ---> **Arduino GND** (这就是共地，**绝对不能忘**)
*   *注意：此时不要接舵机电源，只接信号线，防止意外乱动。*

#### 2. 飞控参数配置 (告诉飞控去控制 Arduino)
连上 Mission Planner，连接飞控，进入 **CONFIG -> Full Parameter List**。

搜索并修改以下参数（假设你接的是 TELEM2）：

1.  **串口协议设置：**
    *   `SERIAL2_PROTOCOL` = **28** (Scripting) 或者如果你写了专门的驱动可能是 **Dev/User**。
    *   *修正：* 既然我们是自己在 C++ 里直接操作串口（通过 `AP_SerialManager`），你需要把你代码里注册的那个协议号对应上。通常如果你没注册新协议，只是在代码里写死调用 Serial2，那么这里可能需要设置为 **-1** (None) 防止系统占用，或者设置为一个自定义值并在代码里查找。
    *   **更稳妥的做法（我们在代码里用的 `find_serial`）：**
        如果你在代码里写的是 `find_serial(AP_SerialManager::SerialProtocol_Scripting, 0)`，那么这里就设为 **28**。
        *   `SERIAL2_BAUD` = **57** (即 57600，需与 Arduino 代码一致)。

2.  **通道 9 设置：**
    *   `SERVO9_FUNCTION` = **59** (RCIN9，透传测试) 或 **0** (Disabled，完全由你的代码接管)。
    *   *建议设为 0，因为你的 C++ 代码会接管它的输出，设为 59 可能会冲突。*

3.  **解除安全开关（仅用于测试）：**
    *   `BRD_SAFETYENABLE` = **0**

---

### ⚠️ 安全检查清单 (Pre-flight Check)

在通电测试前，请务必确认：
1.  **没有螺旋桨！没有螺旋桨！**
2.  飞控和 Arduino 供电正常（USB 或 电池）。
3.  Arduino 烧录的是最新的 Slave 程序。
4.  飞控烧录的是最新的 Custom 固件。

**一切准备就绪后，你可以通电，推一下 Channel 9，看看 Arduino 的串口监视器有没有收到数据，或者舵机动没动！**
