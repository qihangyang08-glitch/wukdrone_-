### 1
  在 SIM_Frame.cpp 中（wuk_motors 定义处），四个电机用带有可倾斜参数的 Motor 构造函数注册：每个 Motor 的第 5..7 个参数是 roll_servo、roll_min、roll_max（例如所有四个 motor 的 roll_servo 都是 8 -> 对应 RC 通道 9，即 input.servos[8]），pitch_servo 未使用。这个定义决定了哪些电机可由通道 9 驱动倾转以及目标倾角范围（0 到 ±90 度）。（文件: SIM_Frame.cpp，wuk_motors 数组）
### 2
  在 Frame::calculate_forces（SIM_Frame.cpp）中实现了 RC9 -> 目标 PWM 的映射与平滑：读取 input.servos[8]（rc9），把 rc9 值映射到目标外部 PWM（1000..2000），用 tilt_speed_deg_per_sec 和 pwm_per_deg 做每帧的平滑（external_current_pwm_f），然后对每个 motor 调用 motors[i].set_external_roll_pwm(roundf(external_current_pwm_f[i])) 并随后调用 motors[i].calculate_forces(...) 来应用该外部 PWM。该逻辑负责把 RC 通道输入转为对每个电机的外部 roll PWM 覆盖。（文件: SIM_Frame.cpp，Frame::calculate_forces）
### 3
  在 Motor::calculate_forces（SIM_Motor.cpp）中读取并应用外部 roll PWM：如果 roll_servo >= 0，函数优先使用 external_roll_pwm（若非 -1）或读取实际 servo 通道，调用 update_servo 将 PWM 平滑为 servoval，再按 roll_min/roll_max 将 servoval 映射为具体 roll 角度（度）。然后用 rotation.from_euler(radians(roll), radians(pitch), 0) 构建旋转矩阵并把原始 thrust（由 thrust_vector * motor_thrust 计算）乘以该矩阵，从而旋转推力向量；yaw torque 同样被旋转。默认 thrust_vector 初值为 (0,0,-1)，因此 roll=±90° 会把推力从垂直方向旋转到水平方向，导致垂直升力消失（受控下坠）。（文件: SIM_Motor.cpp，函数 Motor::calculate_forces；以及 SIM_Motor.h 中的 Motor 构造函数初始化 thrust_vector = (0,0,-1)）
### 4
  在 Motor::calculate_forces（SIM_Motor.cpp）中读取并应用外部 roll PWM：如果 roll_servo >= 0，函数优先使用 external_roll_pwm（若非 -1）或读取实际 servo 通道，调用 update_servo 将 PWM 平滑为 servoval，再按 roll_min/roll_max 将 servoval 映射为具体 roll 角度（度）。然后用 rotation.from_euler(radians(roll), radians(pitch), 0) 构建旋转矩阵并把原始 thrust（由 thrust_vector * motor_thrust 计算）乘以该矩阵，从而旋转推力向量；yaw torque 同样被旋转。默认 thrust_vector 初值为 (0,0,-1)，因此 roll=±90° 会把推力从垂直方向旋转到水平方向，导致垂直升力消失（受控下坠）。（文件: SIM_Motor.cpp，函数 Motor::calculate_forces；以及 SIM_Motor.h 中的 Motor 构造函数初始化 thrust_vector = (0,0,-1)）
### 5
  额外注意事项：Motor::calculate_forces 包含对 thrust_vector 非有限或为零的检查，会把其重置为 (0,0,-1) 并打印警告，避免除零/NaN；Frame::calculate_forces 中对外部 PWM 做了速率限制和平滑（tilt_speed_deg_per_sec 及 pwm_per_deg），并把每帧结果通过 set_external_roll_pwm 传入 Motor。Motor::update_servo 模拟了舵机速度限制，影响最终 roll 角随时间的变化。
### 整体实现情况
  已实现完整的 RC9 驱动的“折臂/倾转”控制路径：SIM_Frame.cpp 将 RC9 映射并平滑为外部 roll PWM；wuk_motors 的 Motor 构造函数把 roll_servo 索引和目标角度范围配置给每个电机；SIM_Motor.cpp 的 Motor::calculate_forces 读取外部 PWM、计算 roll 角并通过旋转矩阵直接旋转该电机的 thrust 向量，从而在物理层面把垂直推力转为水平推力，实现预期的“从 (0,0,-1) 变为 (0,±1,0)”行为。整体实现看起来一致且可运行（有日志/调试输出和速率/舵机平滑），但要注意 thrust_vector 的保护重置逻辑可能掩盖外部对 thrust_vector 的直接修改（当前实现没有直接在 Frame 层写入 thrust_vector，而是通过外部 roll PWM 驱动 Motor 内的姿态旋转）。
